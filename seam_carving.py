# -*- coding: utf-8 -*-
"""seam-carving-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nI84vy1h_enbD3aCJA2L9VxYTrjGLoIQ
"""

import numpy as np 
import matplotlib.pyplot as plt
from PIL import Image
from tqdm import tqdm

class SeamCarver:
    def __init__(self, img, _iter):
        """
            self.img - матрица исходного изображения
            self.iter - число итераций исключения швов
            self.rows - количество строк в матрице изображения
            self.cols - количество столбцов в матрице изображения (меняется при исключении швов)
            self.red - матрица красного компонента изображения
            self.green - матрица зеленого компонента изображения
            self.blue - матрица синего компонента изображения
            self.energy_map - матрица энергии кажого пикселя
            self.path_weights - матрица с минимальными суммарными энергиями швов до кажого пикселя (сверху вниз)
            self.shifts - карта сдвигов для трассировки пути с минимальной энергией
            self.seam_map - булевая карта исключенных пикселей
        """

        self.img = img
        self.mask = None
        self.iter = _iter
        self.rows = self.img.shape[0]
        self.cols = self.img.shape[1]
        self.red = self.img[:, :, 0]
        self.green = self.img[:, :, 1]
        self.blue = self.img[:, :, 2]
        self.energy_map = None
        self.path_weights = None
        self.shifts = None
        self.seam_map = np.ones(self.red.shape, dtype=bool)
        self.seam_coords = np.zeros((self.iter, self.rows), dtype=int)
        self.current_iter = 0
        self.cropped_img = None
        self.expanded_img = None
        self.clusters = None
        self.generated_mask = None

    def get_energy_map(self):
        """
            Метод подсчета матрицы энергий:

            1. Создается расширенная матрица, для обработки крайних пикселей
            со всех сторон приписываются противополжные крайние столбец/строка

            2. Происходит вычисление энергии
        """

        img_R = self.red[self.seam_map].reshape((self.rows, self.cols))
        img_G = self.green[self.seam_map].reshape((self.rows, self.cols))
        img_B = self.blue[self.seam_map].reshape((self.rows, self.cols))

        if self.mask is not None:
            current_mask = self.mask[self.seam_map].reshape((self.rows, self.cols))

        img_R_x = np.concatenate((np.array([img_R[:, self.cols-1]]).T, img_R, np.array([img_R[:, 0]]).T), axis=1)
        img_G_x = np.concatenate((np.array([img_G[:, self.cols-1]]).T, img_G, np.array([img_G[:, 0]]).T), axis=1)
        img_B_x = np.concatenate((np.array([img_B[:, self.cols-1]]).T, img_B, np.array([img_B[:, 0]]).T), axis=1)

        img_R_y = np.concatenate((np.array([img_R[self.rows-1]]), img_R, np.array([img_R[0]])), axis=0)
        img_G_y = np.concatenate((np.array([img_G[self.rows-1]]), img_G, np.array([img_G[0]])), axis=0)
        img_B_y = np.concatenate((np.array([img_B[self.rows-1]]), img_B, np.array([img_B[0]])), axis=0)

        deltaX = (np.square(img_R_x[:, 2:] - img_R_x[:, :-2]) +
                np.square(img_G_x[:, 2:] - img_G_x[:, :-2]) +
                np.square(img_B_x[:, 2:] - img_B_x[:, :-2]))
        deltaY = (np.square(img_R_y[2:] - img_R_y[:-2]) +
                np.square(img_G_y[2:] - img_G_y[:-2]) +
                np.square(img_B_y[2:] - img_B_y[:-2]))

        
        self.energy_map = np.sqrt(deltaX + deltaY)
        if self.mask is not None:
            max_val = np.max(self.energy_map)
            self.energy_map += current_mask * (max_val * max_val)

    def get_path_map(self):
        """
            Метод подсчета энергии швов:

            1. Для каждого пикселя в строке происходит выбор пикселя
            с минимальным значением суммарной энергии из трех соседей строкой выше

            2. Запоминается сдвиг выбранного пикселя относительно рассматриваемого по горизонтальной координате

            3. По показатель суммарной энергии для рассматриваемого пикселя
            равен сумме его собственной энергии и суммарной энергии выбранного пикселя
        """

        if self.energy_map is None:
            return

        self.path_weights = np.copy(self.energy_map)
        self.shifts = np.zeros(self.energy_map.shape, dtype='int64')

        for i in range(1, self.path_weights.shape[0]):
            for j in range(self.path_weights.shape[1]):
                if j == 0:
                    shift = self.path_weights[i-1, j:j+2].argmin()
                elif j == self.path_weights.shape[1] - 1:
                    shift = self.path_weights[i-1, j-1:j+1].argmin() - 1
                else:
                    shift = self.path_weights[i-1, j-1:j+2].argmin() - 1
                self.shifts[i, j] = shift
                self.path_weights[i, j] += self.path_weights[i-1, j+shift]
    
    def remove_seam(self):
        """
            Метод исключения шва из изображения:

            1. Создается булевая карта исключенных пикселей

            2. В последней строке выбирается пиксель с минимальной накопленной энергией,
            данный показатель эквивалентен шву с минимальной энергией

            3. По сдвигам для данного пикселя на булевой карте отмечаются пиксели сообтветствующего шва

            4. Булевая карта расширяется до размеров исходного изображения с учетом ранее исключенных пикселей
        """

        if self.path_weights is None:
            return

        new_map = np.ones(self.path_weights.shape, dtype=bool)
        y = self.path_weights[-1].argmin()
        new_map[self.rows - 1, y] = False

        for i in range(self.rows - 2, -1, -1):
            y = y + self.shifts[i + 1, y]
            new_map[i, y] = False

        old_map = np.copy(self.seam_map)
        self.seam_map[self.seam_map == True] = new_map.reshape(self.rows * self.cols)
        _, new_y = np.where(self.seam_map != old_map)
        self.seam_coords[self.current_iter] = new_y
        self.current_iter += 1
        self.cols -= 1

    def count_seams(self):
        for i in tqdm(range(self.iter)):
            self.get_energy_map()
            self.get_path_map()
            self.remove_seam()

    def crop_image(self):
        r = self.red[self.seam_map].reshape((self.rows, self.cols))
        g = self.green[self.seam_map].reshape((self.rows, self.cols))
        b = self.blue[self.seam_map].reshape((self.rows, self.cols))
        self.cropped_img = np.dstack((r, g, b))

    def expand_image(self):
        """
            Метод расширения изображения:

            1. Для расширения используем список швов, отобранных для исключения из картинки,
            поскольку расширение каждого шва должно быть независимо от предыдушего расширения
            (иначе добавление новых пикселей будет концентрироваться в одном месте)

            2. Для каждого шва добавляем дополнительный шов справа, где цветовые значения вычисляются
            как среднее арифметическое левого и правого соседей.
        """

        expanded_red = np.zeros((self.img.shape[0], self.img.shape[1] + self.iter), dtype='int64')
        expanded_green = np.zeros((self.img.shape[0], self.img.shape[1] + self.iter), dtype='int64')
        expanded_blue = np.zeros((self.img.shape[0], self.img.shape[1] + self.iter), dtype='int64')

        for i in range(self.img.shape[0]):
            count = 0
            row = np.sort(self.seam_coords[:, i])

            for j in range(self.img.shape[1]):
                expanded_red[i][j + count] = self.red[i][j]
                expanded_green[i][j + count] = self.green[i][j]
                expanded_blue[i][j + count] = self.blue[i][j]

                if count < self.iter and j == row[count]:
                    count += 1
                    if j < self.img.shape[1] - 1:
                        expanded_red[i][j + count] = (self.red[i][j] + self.red[i][j+1]) / 2
                        expanded_green[i][j + count] = (self.green[i][j] + self.green[i][j+1]) / 2
                        expanded_blue[i][j + count] = (self.blue[i][j] + self.blue[i][j+1]) / 2
                    else:
                        expanded_red[i][j + count] = self.red[i][j]
                        expanded_green[i][j + count] = self.green[i][j]
                        expanded_blue[i][j + count] = self.blue[i][j]

        self.expanded_img = np.dstack((expanded_red, expanded_green, expanded_blue))

    def add_mask(self, _mask):
    	# Метод задания маски изображения

        if _mask.shape[:2] != self.img.shape[:2]:
            return

        self.mask = np.round((_mask[:, :, 1] - _mask[:, :, 0]) / 255)

    def mask_assign_classes(self, seg_num, r, g, b):
        clusters = np.zeros((self.img.shape[0], self.img.shape[1]), dtype='int64')

        for i in range(seg_num):
            means = np.sqrt(np.square(self.red - r[i]) +
                            np.square(self.green - g[i]) +
                            np.square(self.blue - b[i]))
            if i == 0:
                diff = np.copy(means)
            diff = np.minimum(means, diff)
            clusters[means - diff == 0] = i

        return clusters

    def generate_mask(self, seg_num=2):
        if self.clusters is None:
            self.clusters = np.zeros((self.img.shape[0], self.img.shape[1]), dtype='int64')

        Y = [i for i in range(0, self.img.shape[1], round(self.img.shape[1]/seg_num))][:seg_num]
        x = round(self.img.shape[0]/2)
        centers = [(x, y) for y in Y]
        center_R = [self.red[x, y] for x, y in centers]
        center_G = [self.green[x, y] for x, y in centers]
        center_B = [self.blue[x, y] for x, y in centers]

        for k in range(10):
            new_clusters = self.mask_assign_classes(seg_num, center_R, center_G, center_B)

            if len(self.clusters[self.clusters - new_clusters != 0]) < self.clusters.shape[0] * self.clusters.shape[1] * 0.03:
                self.clusters = new_clusters
                break
            self.clusters = new_clusters   

            for i in range(seg_num):
                mean_R = self.red[self.clusters == i]
                mean_G = self.green[self.clusters == i]
                mean_B = self.blue[self.clusters == i]

                center_R[i] = np.round(np.sum(mean_R) / len(mean_R))
                center_G[i] = np.round(np.sum(mean_G) / len(mean_G))
                center_B[i] = np.round(np.sum(mean_B) / len(mean_B))
        
        mask_R = np.zeros((self.img.shape[0], self.img.shape[1]), dtype='int64')
        mask_G = np.zeros((self.img.shape[0], self.img.shape[1]), dtype='int64')
        mask_B = np.zeros((self.img.shape[0], self.img.shape[1]), dtype='int64')

        for i in range(seg_num):
            mask_R[self.clusters == i] = center_R[i]
            mask_G[self.clusters == i] = center_G[i]
            mask_B[self.clusters == i] = center_B[i]

        self.generated_mask = np.dstack((mask_R, mask_G, mask_B))
            
    def show_energy_map(self):
        plt.imshow(self.energy_map, cmap='Greys_r')

    def show_cropped_image(self, figsize=(12, 12)):
        if self.cropped_img is None:
            return

        plt.figure(figsize=figsize)
        plt.imshow(self.cropped_img)

    def show_expanded_image(self, figsize=(12, 12)):
        if self.expanded_img is None:
            return

        plt.figure(figsize=figsize)
        plt.imshow(self.expanded_img)

    def show_paths(self, color='red', figsize=(12, 12)):
    	# Метод визуализации исключенных швов

        plt.figure(figsize=figsize)
        for i in range(self.seam_coords.shape[0]):
            plt.scatter(self.seam_coords[i], range(self.rows), 0.1, color=color)
        plt.imshow(self.img)

    def show_generated_mask(self, figsize=(12, 12)):
        if self.generated_mask is None:
            return
        
        plt.figure(figsize=figsize)
        plt.imshow(self.generated_mask)

    def save_results(self, filename="img"):
        r = np.copy(self.red)
        g = np.copy(self.green)
        b = np.copy(self.blue)
        r[np.invert(self.seam_map)] = 255
        g[np.invert(self.seam_map)] = 0
        b[np.invert(self.seam_map)] = 0
        img_with_lines = np.dstack((r, g, b))

        if self.cropped_img is not None:
            Image.fromarray(np.uint8(self.cropped_img)).save("{}_cropped.png".format(filename))
        if self.expanded_img is not None:
            Image.fromarray(np.uint8(self.expanded_img)).save("{}_expanded.png".format(filename))
        if self.seam_map is not None:
            Image.fromarray(np.uint8(img_with_lines)).save("{}_with_lines.png".format(filename))
        if self.generated_mask is not None:
            Image.fromarray(np.uint8(self.generated_mask)).save("{}_mask.png".format(filename))

# Usage

img = np.array(Image.open('img.jpg'), dtype='int64')
mask = np.array(Image.open('mask.jpg'), dtype='int64')
sc = SeamCarver(img, 100)
sc.add_mask(mask)
sc.count_seams()
sc.crop_image()
sc.expand_image()
sc.generate_mask(3)
sc.save_results('result')